// This file needs -*- c++ -*- mode
// ============================================================================
// Nova. (c) 2008 Ken Reed
//
// This is free software. You can redistribute it and/or modify it under the
// terms of the GNU General Public License version 2 as published by the Free
// Software Foundation.
// ============================================================================

using System;
using System.Collections;
using System.Drawing;

namespace NovaCommon
{

// ============================================================================
// Star Class
// ============================================================================

   [Serializable]
   public class Star : Item
   {
      public bool            OrbitingFleets         = false;
      public ProductionQueue ManufacturingQueue     = new ProductionQueue();
      public Resources       MineralConcentration   = new Resources();
      public Resources       ResourcesOnHand        = new Resources();
      public Fleet           Starbase               = null;
      public int             Colonists              = 0;
      public int             Defenses               = 0;
      public int             Factories              = 0;
      public int             Mines                  = 0;
      public int             ResearchAllocation     = 0;
      public int             ScanRange              = 0;
      public string          DefenseType            = "None";
      public string          ScannerType            = "None";

      // The following values are percentages of the permissable range of each
      // environment parameter (between 0 and 100).

      public int             Gravity                = 0;
      public int             Radiation              = 0;
      public int             Temperature            = 0;

// ---------------------------------------------------------------------------

      private Race           ThisRace = null;

// ============================================================================
// Update a star to take into account the passing of a year.
// ============================================================================

      public void Update(Race race)
      {
         UpdatePopulation(race);
         UpdateResources(race);
      }


// ============================================================================
// Update the population of a star system
// ============================================================================
 
      private void UpdatePopulation(Race race)
      {
         double habitalValue = HabitalValue(race);
         double growthRate   = race.GrowthRate / 100;

         if (race.Type == "HyperExpansion") {
            growthRate *= 2;
         }

         double populationGrowth = Colonists * growthRate * habitalValue;
         double capacity         = Colonists / race.MaxPopulation;

         if (race.Type == "HyperExpansion") {
            capacity /= 2;
         }

         if (capacity > 0.25) {
            double crowdingFactor = 1.75;
            crowdingFactor       *= (1.0 - capacity) * (1.0 - capacity);
            populationGrowth     *= crowdingFactor;
         }

         Colonists += (int) populationGrowth;
      }


// ============================================================================
// Update the resources available to a star system.
// ===========================================================================

      private void UpdateResources(Race race)
      {
         // A certain number of colonists will generate a resource each year.
         // This has a default of 1000 colonists per resource but can be
         // channged on a per race basis in the Race Designer.

         ResourcesOnHand.Energy = Colonists / race.ColonistsPerResource;

         // In addition, resources are generated by factories that are capable
         // of being manned. Again this is set in the Race Deigner with a
         // default of 1k colonists needed to man each factory. Note that the
         // actual number of existing factories may be less than the number
         // that are capable of being manned.

         double potentialFactories = Colonists / race.OperableFactories;
         double factoriesInUse     = Math.Min(Factories, potentialFactories); 

         ResourcesOnHand.Energy    += factoriesInUse * race.FactoryProduction;

         ThisRace = race;
         ResourcesOnHand.Ironium   += Mine(ref MineralConcentration.Ironium);
         ResourcesOnHand.Boranium  += Mine(ref MineralConcentration.Boranium);
         ResourcesOnHand.Germanium += Mine(ref MineralConcentration.Germanium);
         ResourcesOnHand.Energy    -= ResearchAllocation;
      }


// ===========================================================================
// Mine minerals.
//
// Mining rate = Number of Mines * Efficiency * Mineral Concentration %.
//
// Mining efficiency is a race parameter (MineProductionRate per 10 mines)
// Concentration is in % and is normalised so that 1.0 = 100%
// ===========================================================================

      private double Mine(ref double concentration)
      {
         // As with factories, mines must be manned to be able to produce.
         // Again this is set in the Race Deigner with a default of 1k
         // colonists needed to man each mine and, as with factories, the
         // actual number of existing mines may be less than the number that
         // are capable of being manned.
         //
         // The potential number of mines that might be capable of being used
         // is a race parameter which determines how many mines may be
         // operated by 10K colonists.
  

         double potentialMines = (Colonists / 10000) * ThisRace.OperableMines;
         double minesInUse     = Math.Min(Mines, potentialMines); 

         double mined = ((minesInUse / 10) * ThisRace.MineProductionRate) 
                      * (concentration / 100);

         // Reduce the mineral concentration. This is just an approximation of
         // the Stars! algorithm for now. Concentration will drop by 1 point
         // after 12500/concentration kT have been mined. So we just reduce the
         // concentration by a proportion according to how much has been mined
         // this year.

         concentration -= mined / (12500.0 / concentration);

         if (concentration < 1) {
            concentration = 1;
         }

         return mined;
      }


// ============================================================================
// Return the utilised capacity (as a percentage).
// ============================================================================

      public int Capacity(Race race)
      {
         double maxPopulation = race.MaxPopulation;
         if (race.Type == "HyperExpansion") {
            maxPopulation /= 2;
         }

         double capacity =(Colonists / maxPopulation) * 100;
         return (int) Math.Ceiling(capacity);
      }


// ============================================================================
// This algorithm is taken from the Stars! Technical FAQ.
//
// Return the habital value of this star for the specified race (in the range
// -1 to +1 where 1 = 100%). Note that the star environment values are
// percentages of the total range.
//
// The full equation (from the Stars! Technical FAQ) is: 
//
// Hab% = SQRT[(1-g)^2+(1-t)^2+(1-r)^2]*(1-x)*(1-y)*(1-z)/SQRT[3] 
//
// Where g, t,and r (stand for gravity, temperature, and radiation)are given
// by Clicks_from_center/Total_clicks_from_center_to_edge and where x,y, and z
// are:
//
// x=g-1/2 for g>1/2
// x=0 for g<1/2 y=t-1/2 for t>1/2
// y=0 for t<1/2 
// z=r-1/2 for r>1/2
// z=0 for r<1/2 
// ============================================================================

      public double HabitalValue(Race race)
      {
         // Calculate the minimum and maximum values of the tolerance ranges
         // expressed as a percentage of the total range. (Radiation is in the
         // range 0-100 so the values already can be thought of as a
         // percentage.

         double rMinimum = race.RadiationTolerance.Minimum;
         double rMaximum = race.RadiationTolerance.Maximum;

         // Get the span of the range and its centre.

         double rSpan    = rMaximum - rMinimum ;
         double rCentre  = rMinimum  + (rSpan / 2);

         // Find out how far away the star value is from the ideal.

         double rDistance = Math.Abs(rCentre - Radiation);

         // Normalisize the distance to be in the range 0 to 1.

         double r = rDistance / rSpan;

         // Now do the same for the other two parameters. Gravity is in the
         // range 0 to 10.

         double gMinimum  = race.GravityTolerance.Minimum * 10;
         double gMaximum  = race.GravityTolerance.Maximum * 10;
         double gSpan     = gMaximum - gMinimum;
         double gCentre   = gMinimum  + (gSpan / 2);
         double gDistance = Math.Abs(gCentre - Gravity);
         double g         = gDistance / gSpan;

         // Temperature is in the range -200 to 200.

         double tMinimum  = (200 + race.TemperatureTolerance.Minimum) / 4;
         double tMaximum  = (200 + race.TemperatureTolerance.Maximum) / 4;
         double tSpan     = tMaximum - tMinimum;
         double tCentre   = tMinimum  + (tSpan / 2);
         double tDistance = Math.Abs(tCentre - Temperature);
         double t         = tDistance / tSpan;

         double x         = 0;
         double y         = 0;
         double z         = 0;

         if (g > 0.5) x = g - 0.5;
         if (t > 0.5) y = t - 0.5;
         if (r > 0.5) z = r - 0.5;

         double h = Math.Sqrt(
                         ((1-g) * (1-g)) + ((1-t) * (1-t)) + ((1-r) * (1-r)) 
                              ) * (1-x) * (1-y) * (1-z)
                              / Math.Sqrt(3.0);
         return h;
      }

   }
}
